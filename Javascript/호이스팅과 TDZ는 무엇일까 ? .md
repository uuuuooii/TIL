[블로그 가기](https://blog.naver.com/eunhey2717/222821654942)
## 호이스팅과 TDZ는 무엇일까 ? 
### 호이스팅 이란

- 함수 안에 있는 선언들을 모두 끌어 올려서 해당 함수 유효 스코프의 최상단에 선언 하는 것을 말한다.

(var 선언문이나 function 선언문 등을 해당 스코프의 선두로 옮긴 것처럼 동작하는 특성)

​

[ 호이스팅의 대상 ]

- var 변수 선언과 함수선언문에서만 호이스팅이 일어난다.

- var 변수/함수의 선언만 위로 끌어 올려지며, 할당은 끌어 올려지지 않는다.

- let / const 변수 선언과 함수표현식에서는 호이스팅이 발생하지 않는다.

​

-> var , let , const 키워드로 선언된 변수는 선언 부분만 끌어올려진다고 생각할 수 있다. 따라서 var의 경우에는 변수 선언전에도 참조할 수 있지만 할당을 하지 않았기에 undefined이다.

​

[ let / const 가 호이스팅이 발생하지 않는 이유 ]

: 식별자가 호이스팅 후 실제 코드에서 선언되기 전까지 TDZ(Temporal Dead Zone/ 일시적 사각지대)에 있기 때문에 let, const 선언코드가 있는 곳 이전에는 해당 변수에 참조할 수 없게 된다.

​
==
Temporal Dead Zone(TDZ)

참조 오류가 나는 구간인 스코프 시작지점부터 초기화 지점까지의 구간.

초기화가 되기 전까지는 TDZ라는 곳에 머물러서 초기화(혹은 할당)이 될 때까지 잠시 '죽어있는 상태'이기 때문에 선언 전에 참조가 불가능한 것.

선언 전에 변수를 사용하는 것을 비허용하는 개념상의 공간이다.

​
```javascript
console.log(a); // undefined
f1(); // undefined
console.log(f2) // undefined
f2(); // TypeError: f2 is not a function
function f1(){
  console.log(b);
  var b = 5;
}
var f2 = function () {
  console.log(c);
  var c = 7;
}
var a = 10;
```

지역 변수 : Block{}안에서 선언된 변수. Block 안에서만 쓸 수 있음.

전역 변수 : Block{}밖에서 선언을 한 어디서든 쓰일 수 있는 변수

​

호이스팅 시 function 안에서 쓴 것 빼고는 전부 전연변수라고 생각하면 된다.

​

참고로 const, let 말고도 class 구문과 클래스의 constructor() 내부의 super(), 기본 함수 매개변수도 TDL 제한이 있다. 반면 var , function 구문은 TDZ에 영향을 받지 않으며 현재 스코프에서 호이스팅이 된다.

​

[ 스코프 Scope ]

변수나 함수에 접근할 수 있는 위치를 말한다.
```javascript
function foo() {
var x;
}
```
-> 위의 예시에서 x의 스코프는 함수 foo()이다.

​

​

###  함수선언문, 함수표현식과 호이스팅 

자바스크립트에서 함수를 선언하는 방법은 2가지가 있다.

1. 함수 선언문

```javascript
function myFunc() {
         // do something...
}
2. 함수 표현식

const myFunc2 = function() {
        // do something...
}
```
두 가지 표현 모두 다 호출하는 방식은 동일하다.

​
```javascript
myFunc();
myFunc2();
```
두 선언방식의 차이점

​

함수 선언문은 이른바 호이스팅(hoisting)이라는 자바스크립트의 고유한 특성에 영향을 받는다.

​

​
==
###  let, const, var, function  원리 

[ var ]

es6 이전애는 변수를 선언할 때 var를 이용하여 변수를 선언하였다.

​

var의 경우엔 function 단위의 scope를 가진다. 이는 함수안에서만 선언 될 경우에 scope를 가지는 것을 의미한다.

if나 for문안에서 var를 선언할 경우 해당 변수는 scope를 if나 for가 아닌 상위의 함수(없으면 전역)를 scope로 가지게 된다.
```javascript
function func() {
	var a = 1; // func scope
 }
 
 console.log(a) // error
 
 for(var i =0; i<10;i++) {
 	var b = 2; // 전역 scope
 }
 
 console.log(b) // 2
 ```
b가 scope가 전역으로 설정이 되면서 다음과 같이 이상한 코드가 발생하게 된다.

​

function scope와 호이스팅 개념이 만나 다음과 같은 원리로 동작된다고 생각하면 된다.(실제로 이렇게 동작하진 않는다.
```javascript
var b;
function func() {
	var a;
	a = 1;
 }
 
 console.log(a) // error
 
 for(var i =0; i<10;i++) {
 	b = 2; 
 }
 
 console.log(b) // 2
```

[ let, const ]

let과 const는 es6 이후에 선언 되었다.

위에 처럼 이상한 코드가 실제로 코드를 작성하는 입장에서는 헷갈릴 만한 요소가 많아 block scope로 설정되었다.

block scope는 중괄호 단위로 스코프가 설정되는 것으로 이해하면 된다.

그로인해 for문과 if문안에서 선언할 경우에는 if문과 for문 안에서만 사용가능한 변수로 설정이 된다.

​
```javascript
const b = 1;

for(var i =0; i<10; i++) {
 	coonsole.log(b) // error
    const b = 2; 
}
```
[ let, const는 호이스팅이 일어나지 않나요? ]

이렇게 보면, const, let 에선 호이스팅이 일어나지 않는 것처럼 보인다.

하지만 호이스팅이란 개념은 결국 실행컨텍스트로 인해 발생하는 것임으로 const, let, var 모두 호이스팅이 발생한다.

그러면 왜 호이스팅이 일어나지 않는 것 처럼 보이는 걸까?

이는 const와 let의 값 할당 시점이 var와 다르기 때문이다.

​

일반적으로 변수는 다음과 같이 실행된다.

변수 선언 > 변수 초기화 > 변수 값 할당

​

var 의 경우는 변수의 선언과 초기화가 동시에 일어난다.

이말인 즉 변수가 초기화가 되는데 할당이 되기 이전의 상태로 undefiend상태로 존재하게 된다.

​

그러나 let과 const는 변수의 선언과 초기화가 동시에 일어나지 않는다.

변수의 선언만 인정되어 실행 컨택스트에는 담기게 되나 (호이스팅이 일어난다.) 초기화가 되지 않았기 때문에 초기화 되기 이전에 console 로 실행시키게 되면 error가 발생하게 된다.

​

[ 결론 ]

### var 

- function scope

- 호이스팅이 일어난다

- 변수의 선언과 초기화가 동시에 진행

​

### let, const

- pblock scope

- 호이스팅이 일어난다

- 변수의 선언만 일어난다. 변수의 선언과 초기화가 동시에 일어나지 않는다.

​

​

## 실행 컨텍스트와 콜 스택

[ 함수 실행에 대한 이해 ]

- 자바스크립트는 하나의 스레드로 단 1개의 동시성만 다루는 언어

    -한번에 1개의 작업만 다룰 수 있다.

    -JS의 Heap Queue Stack => 크롬의 V8 내부에 구현되어 있다.

​

1. 콜스택 CallStack

- 함수의 호출을 기록하는 자료구조

- 우리가 프로그램 안에서 위치한 곳

- 함수 실행 시 스택에 push 된다.

- 함수로부터 반환 받을 때, 스택에서 pop된다.

​

2. 힙 Heap

- 오브젝트(객체)들은 힙 내부에 할당

- 거의 구조화되지 않은 영역(unsteuctured)의 메모리

- 변수와 객체들의 모든 메모리 할당이 여기서 일어남

​

3. 큐 Queue

- 자바스크립트 런타임은 메시지 큐를 갖고 있다.

- 메세지 큐 

- 실행될 콜백함수나 실행될 메세지들에 대한 리스트

- 스택이 충분한 공간(capacity)를 갖고 있을 때, 메세지는 큐 밖으로 나오고 메세지가 가지고 있던 함수 목록들이 실행된다. -> 초기 스택 프레임

- 스택이 다시 빌 때 메세지 수행도 끝난다.

- 이벤트들에 대한 콜백 함수가 제공되었다면 메세지들은 외부 비동기 이벤트들에 대한 응답으로 큐에 쌓인다.

- 외부 비동기 이벤트들이란 마우스 클릭, HTTP요청 등을 말합니다. 하지만 만일 한 사용자가 버튼을 눌렀는데 아무런 콜백함수도 등록되어 있지 않다면 어떠한 메시지도 큐에 들어가지 않을 것입니다.

- 메시지들은 웹 브라우저에서 언제든 이벤트가 발생했을 때 추가 된다.

​

​

[ 실행 컨텍스트 ]

- 실행 컨텍스트는 scope, hoistiong, this, function, closure 등의 동작원리를 담고 있는 자바스크립트의 핵심원리이다.

- ESMAScript 스펙에 따르면 실행 컨텍스트를 실행 가능한 코드를 형성화하고 구분하는 추상적인 개념이라고 정의한다.좀 더 쉽게 말하자면 실행 컨텍스트는 실행 가능한 코드가 실행되기 위해 필요한 환경 이라고 말할 수 있겠다. 여기서 말하는 실행 가능한 코드는 아래와 같다.

- 전역 코드 : 전역 영역에 존재하는 코드

- Eval 코드 : eval 함수로 실행되는 코드

- 함수 코드 : 함수 내에 존재하는 코드

- 일반적으로 실행 가능한 코드는 전역 코드와 함수 내 코드이다.

​

​

자바스크립트 엔진은 코드를 실행하기 위하여 실행에 필요한 여러가지 정보를 알고 있어야 한다. 실행에 필요한 여러가지 정보란 아래와 같은 것들이 있다.

- 변수 : 전역변수, 지역변수, 매개변수, 객체의 프로퍼티

- 함수 선언

- 변수의 유효범위(Scope)

- this

이와 같이 실행에 필요한 정보를 형상화하고 구분하기 위해 자바스크립트 엔진은 실행 컨텍스트를 물리적 객체의 형태로 관리한다.

- 컨트롤이 실행 가능한 코드로 이동하면 논리적 스택 구조를 가지는 새로운 실행 컨텍스트 스택이 생성된다. 스택은 LIFO(Last In First Out, 후입 선출)의 구조를 가지는 나열 구조이다.

- 전역 코드(Global code)로 컨트롤이 진입하면 전역 실행 컨텍스트가 생성되고 실행 컨텍스트 스택에 쌓인다. 전역 실행 컨텍스트는 애플리케이션이 종료될 때(웹 페이지에서 나가거나 브라우저를 닫을 때)까지 유지된다.

- 함수를 호출하면 해당 함수의 실행 컨텍스트가 생성되며 직전에 실행된 코드 블록의 실행 컨텍스트 위에 쌓인다.

- 함수 실행이 끝나면 해당 함수의 실행 컨텍스트를 파기하고 직전의 실행 컨텍스트에 컨트롤을 반환한다.

​

​

### 스코프 체인, 변수 은닉화

[ 스코프 체인(scope chain)이란? ]

스코프 체인은 일종의 리스트로서 전역 객체와 중첩된 함수의 스코프의 레퍼런스를 차례로 지정하고, 의미 그대로 각각의 스코프가 어떻게 연결 (chain)되고 있는지 보여주는 것을 말한다.

하지만 스코프 체인을 이해하기 위해서 먼저 자바스크립트의 실행 컨택스트를 알아야함.

​

[ 실행 컨텍스트에서 스코프 체인은 어떻게 작동하는 가? ]

실행 컨텍스트는 LIFO(Last in, First out )구조의 스택으로, 코드 실행 중에 생성된 모든 실행 컨텍스트를 저장하는 데 사용 된다.

실행 컨텍스트가 실행 되면, 엔진이 스코프 체인을 통해 렉시컬 스코프를 먼저 파악한다.

그러고 나서, 함수가 중첩 상태일때 하위

 함수 내에서 상위 함수의 스코프와 전역 스코프까지 참조할 수 있는 데 이것을 스코프 체인을 통해 탐색하는 것이다.

```javascript
var v = "전역 변수";

function a() {
//function a Execution Context(EC)
	var v = "지역 변수";
    
    function b() {
    	//function b Execution Context
    	console.log(v);
    }
    
    b();
}

//Global Execution Context
a();
```

[실습]
```javascript
// 콘솔에 찍힐 b 값을 예상해보고, 어디에서 선언된 “b”가 몇번째 라인에서 호출한 console.log에 찍혔는지, 왜 그런지 설명해보세요.
// 주석을 풀어보고 오류가 난다면 왜 오류가 나는 지 설명하고 오류를 수정해보세요.
let b = 1;

function hi () {

const a = 1;
let b = 100;

b++;


console.log(a,b);
}

//console.log(a);

console.log(b);
// let b = 1; 이 함수 밖에서 선언되었다.
// 전역변수는 함수 외부에서 선언된 변수로, 프로그램 전체에서 접근할 수 있는 변수이기 때문에 b = 1 이 나왔다.
hi();
// 함수 안에서 콘솔로그를 선언하고 밖에서 hi()으로 호출을 했다.
//a 는 선언한 그대로 출력이 잘 됐고, let 키워드로는 변수 중복 선언이 불가하지만, 재할당은 가능해서 b++로 하나 더해진 값 101이 출력이 됐다.
console.log(b);
// 전역변수로 선언 했던 값 출력
```

```javascript
// 콘솔에 찍힐 b 값을 예상해보고, 어디에서 선언된 “b”가 몇번째 라인에서 호출한 console.log에 찍혔는지, 왜 그런지 설명해보세요.
// 주석을 풀어보고 오류가 난다면 왜 오류가 나는 지 설명하고 오류를 수정해보세요.

let b = 1;
let a = 1;

function hi () {


let b = 100;

b++;

console.log(a,b);

}

console.log(a);
// 에러 해결
// a선언을 function hi()에서 했기 때문에 값을 불러올 수 없었고, 변수를 const로 지정했기 let으로 바꿔주고
// 전역 변수로 바꿔줬다.
```